/* Definition section */
%{
#include "y.tab.h"	/* header file generated by bison */
#define BUF_SIZE 1024

extern YYSTYPE yylval; //YYSTYPE
char buf[BUF_SIZE];
int is_c_comment = 0;
extern FILE *yyout;

/* This macro is used to record code line */
#define CONCAT { strncat(buf, yytext, BUF_SIZE - strlen(buf) - 1); }
%}

/* Define regular expression label */
digit		[0-9]
letter		[a-zA-Z]
integer     {digit}+
float       {digit}+"."{digit}+
id			{letter}+({letter}|{digit})*

%option yylineno

%x COMMENT STRING_STATE

/* Rules section */
%%

 /* Arithmetic */
"+"     {CONCAT return(ADD_OP); }
"-" 	{CONCAT return(SUB_OP); }
"*" 	{CONCAT return(MUL_OP); }
"/" 	{CONCAT return(DIV_OP); }
"%"     {CONCAT return(MOD_OP); }
"++"    {CONCAT return(INC_OP); }
"--"    {CONCAT return(DEC_OP); }

 /* Relational */
">"		{CONCAT return('>');  }
"<"		{CONCAT return('<');  }
">="	{CONCAT return(LE_OP);  }
"<="	{CONCAT return(GE_OP);  }
"=="	{CONCAT return(EQ_OP); }
"!="	{CONCAT return(NE_OP); }

 /* Assignment */
"="		{CONCAT return('='); }
"+="	{CONCAT return(ADD_ASSIGN); }
"-="	{CONCAT return(SUB_ASSIGN); }
"*="	{CONCAT return(MUL_ASSIGN); }
"/="	{CONCAT return(DIV_ASSIGN); }
"%="	{CONCAT return(MOD_ASSIGN); }

 /* Logical */
"&&"	{CONCAT return(AND_OP); }
"||"	{CONCAT return(OR_OP); }
"!"		{CONCAT return('!'); }

 /* Delimiters */
"("		{CONCAT return('('); }
")"		{CONCAT return(')'); }
"{"		{CONCAT return('{'); }
"}"		{CONCAT return('}'); }
"["		{CONCAT return('['); }
"]"		{CONCAT return(']'); }
","		{CONCAT return(','); }

 /* Print Keywords */	
"print"		{CONCAT return(PRINT);  }

 /* Condition and Loop Keywords */
"if"		{CONCAT return(IF);  }
"else"		{CONCAT return(ELSE);  }
"for"		{CONCAT return(FOR);  }
"while"		{CONCAT return(WHILE);  }

 /* Declaration Keywords */
"void"		{CONCAT yylval.string = strdup(yytext); return(VOID); }
"int"		{CONCAT yylval.string = strdup(yytext); return(INT); }
"float"  	{CONCAT yylval.string = strdup(yytext); return(FLOAT); }
"string"  	{CONCAT yylval.string = strdup(yytext); return(STRING); }
"bool"  	{CONCAT yylval.string = strdup(yytext); return(BOOL); }

 /* boolean Keywords */
"true"      {CONCAT }
"false"     {CONCAT }

"return"    {return(RETURN); }

 /* String Constant */
\"				        {CONCAT BEGIN STRING_STATE; }
<STRING_STATE>\"		{CONCAT BEGIN INITIAL; return(STRING_LITERAL); }
<STRING_STATE>[^"]*		{  }

 /* Number Constant */
{integer}	{ 
                CONCAT
                yylval.i_val = atoi(yytext);
                return(I_CONST);
            }
{float}	    {
                CONCAT
                yylval.f_val = atoi(yytext);
                return(F_CONST);
            }

 /* C type Comment */
"/*"				{
                        is_c_comment = 1;
                        CONCAT BEGIN COMMENT;
                        fprintf(yyout, "%d: %s\n", yylineno, buf);
                        buf[0] = '\0';
                    }
<COMMENT>[^*\n]+	{ CONCAT }
<COMMENT>\n			{ 
                        CONCAT BEGIN COMMENT;
                        fprintf(yyout, "%d: %s", yylineno, buf);
                        buf[0] = '\0';
                    }
<COMMENT>"*"		{ CONCAT }
<COMMENT>"*/"		{ CONCAT BEGIN INITIAL; is_c_comment = 0;}

 /* C++ type Comment */
\/\/.*	{ CONCAT return(CPP_COMMENTS); }

 /* Variable ID */
 {id}       { CONCAT yylval.string = strdup(yytext); return(ID); }

 /* others */

[;]         { CONCAT return(SEMICOLON);  }
[\n]        { 
                if(!is_c_comment)
                {
                    CONCAT
                    fprintf(yyout, "%d: %s", yylineno, buf);
                    buf[0] = '\0';
                }
            }
[ \t]		{ CONCAT } /* Ignore */
[^ \t\n] 	{ CONCAT } /* Ignore other charactor sets */
<<EOF>>     { return 0; }

%%

int yywrap()
{
    return 1;
}
