/* Definition section */
%{
// include and define section
// #include "common.h"
#include <string.h>
#include "y.tab.h"	/* header file generated by bison */
#define BUF_SIZE 256

// extern function and declaration
extern YYSTYPE yylval; //YYSTYPE
extern int dump_flag;
extern int had_print_flag;
extern void dump_symbol(int scope);
char buf[BUF_SIZE];
void print_codeline();


/* This macro is used to record code line */
#define CONCAT { strncat(buf, yytext, BUF_SIZE - strlen(buf) - 1); }

/* This macro is used to clean buf[BUF_SIZE] */
#define BUFCLEAN { buf[0] = '\0'; }

%}

/* Define regular expression label */
newline		[\n]
digit		[0-9]
letter		[a-zA-Z]
integer     {digit}+
double      {digit}+"."{digit}+
id			{letter}+({letter}|{digit})*

%option yylineno

%x COMMENT_STATE STRING_STATE

/* Rules section */
%%

 /* Arithmetic */
"+"     { CONCAT return ADD; }
"-"     { CONCAT return SUB; }
"*"     { CONCAT return MUL; }
"/"     { CONCAT return DIV; }
"%"     { CONCAT return MOD;}
"++"    { CONCAT return INC; }
"--"    { CONCAT return DEC; }
 /* Relational */
">"     { CONCAT return MT;  }
"<"     { CONCAT return LT; }
">="    { CONCAT return MTE; }
"<="    { CONCAT return LTE;}
"=="    { CONCAT return EQ; }
"!="    { CONCAT return NE; }

 /* Assignment */
"="     { CONCAT return ASGN; }
"+="    { CONCAT return ADDASGN; }
"-="    { CONCAT return SUBASGN; }
"*="    { CONCAT return MULASGN; }
"/="    { CONCAT return DIVASGN; }
"%="    { CONCAT return MODASGN; }

 /* Logical */
"&&"    { CONCAT return AND; }
"||"    { CONCAT return OR; }
"!"     { CONCAT return NOT;  }

 /* Delimiters */
"("     { CONCAT return LB; }
")"     { CONCAT return RB; }
"{"     { CONCAT return LCB; }
"}"     { CONCAT return RCB; }
"["     { CONCAT return LSB; }
"]"     { CONCAT return RSB; }
","     { CONCAT return COMMA; }

 /* Print Keywords */
"print"     { CONCAT return PRINT; }

 /* Condition and Loop Keywords */
"if"        { CONCAT return IF; }
"else"      { CONCAT return ELSE; }
"for"       { CONCAT return FOR; }
"while"     { CONCAT return WHILE; }

  /* Declaration Keywords */
"void"      { CONCAT; return VOID; }
"int"       { CONCAT; return INT; }
"float"     { CONCAT; return FLOAT; }
"string"    { CONCAT; return STRING; }
"bool"      { CONCAT; return BOOL; }

 /* boolean Keywords */
"true"      { CONCAT; return TRUE; }
"false"     { CONCAT; return FALSE; }

"return"    { CONCAT; return RET; }

 /* String Constant */
\"				        { CONCAT; BEGIN STRING_STATE; }
<STRING_STATE>\"		{ CONCAT; BEGIN INITIAL; }
<STRING_STATE>[^"]*		{
                            CONCAT;
                            yylval.string = (char*)malloc(sizeof(char)*strlen(yytext)+1);
                            strcpy(yylval.string, yytext);
                            return STR_CONST;
                        }

 /* Number Constant */
{integer}	{ CONCAT; yylval.i_val = atoi(yytext); return I_CONST; }
{double}	{ CONCAT; yylval.f_val = atof(yytext); return F_CONST; }

 /* C type Comment */
"/*"				{ CONCAT; BEGIN COMMENT_STATE; }
<COMMENT_STATE>[^*\n]+	{ CONCAT; }
<COMMENT_STATE>\n			{ CONCAT; print_codeline(); }
<COMMENT_STATE>"*"		{ CONCAT; }
<COMMENT_STATE>"*/"		{ CONCAT; BEGIN INITIAL; }

 /* C++ type Comment */
\/\/.*	{ CONCAT; }

 /* Variable ID */
{id}       {
                CONCAT;
                yylval.string = (char*)malloc(sizeof(char)*strlen(yytext)+1);
                strcpy(yylval.string, yytext);
                return ID;
            }

 /* others */

[;]         { CONCAT; return SEMICOLON; }
[\n]        { CONCAT; print_codeline(); }
[ \t]		{ CONCAT; } /* Ignore */
[^ \t\n] 	{ CONCAT; } /* Ignore other charactor sets */
<<EOF>>     { CONCAT; return 0; }


%%

int yywrap()
{
    return 1;
}

void print_codeline(){
    if(had_print_flag == 0){

        if(!strcmp(buf, "\n"))
            printf("%d:", yylineno);
        else
            printf("%d: ", yylineno);
        printf("%s",buf);

        // print_error_after_line();

        BUFCLEAN;

        if(dump_flag >= 0){
            dump_symbol(dump_flag);
            dump_flag = -1;
        }
    }
    else{

        had_print_flag = 0;

        BUFCLEAN;

        // print_error_after_line();

        if(dump_flag >= 0){
            dump_symbol(dump_flag);
            dump_flag = -1;
        }
    }

}
